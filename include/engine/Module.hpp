#pragma once
#include "common.hpp"
#include "string.hpp"
#include "plugin/Model.hpp"
#include "engine/Param.hpp"
#include "engine/Port.hpp"
#include "engine/Light.hpp"
#include "engine/ParamQuantity.hpp"
#include <vector>
#include <jansson.h>


namespace rack {


namespace plugin {
	struct Model;
}


namespace engine {


struct Module {
	plugin::Model *model = NULL;
	/** Automatically generated by the engine. */
	int id = -1;
	/** Arrays of components */
	std::vector<Param> params;
	std::vector<Output> outputs;
	std::vector<Input> inputs;
	std::vector<Light> lights;
	std::vector<ParamQuantity*> paramQuantities;
	/** Access to adjacent modules */
	int leftModuleId = -1;
	Module *leftModule = NULL;
	void *leftProducerMessage = NULL;
	void *leftConsumerMessage = NULL;
	int rightModuleId = -1;
	Module *rightModule = NULL;
	void *rightProducerMessage = NULL;
	void *rightConsumerMessage = NULL;
	/** For CPU meter. */
	float cpuTime = 0.f;
	bool bypass = false;

	/** Constructs a Module with no params, inputs, outputs, and lights. */
	Module();
	/** Use config() instead. */
	DEPRECATED Module(int numParams, int numInputs, int numOutputs, int numLights = 0) : Module() {
		config(numParams, numInputs, numOutputs, numLights);
	}
	virtual ~Module();

	/** Configures the number of Params, Outputs, Inputs, and Lights. */
	void config(int numParams, int numInputs, int numOutputs, int numLights = 0);

	template <class TParamQuantity = ParamQuantity>
	void configParam(int paramId, float minValue, float maxValue, float defaultValue, std::string label = "", std::string unit = "", float displayBase = 0.f, float displayMultiplier = 1.f, float displayOffset = 0.f) {
		if (paramQuantities[paramId])
			delete paramQuantities[paramId];

		Param *p = &params[paramId];
		p->value = defaultValue;

		ParamQuantity *q = new TParamQuantity;
		q->module = this;
		q->paramId = paramId;
		q->minValue = minValue;
		q->maxValue = maxValue;
		q->defaultValue = defaultValue;
		if (!label.empty())
			q->label = label;
		else
			q->label = string::f("#%d", paramId + 1);
		q->unit = unit;
		q->displayBase = displayBase;
		q->displayMultiplier = displayMultiplier;
		q->displayOffset = displayOffset;
		paramQuantities[paramId] = q;
	}

	struct ProcessArgs {
		float sampleRate;
		float sampleTime;
	};

	/** Advances the module by one audio sample.
	Override this method to read Inputs and Params and to write Outputs and Lights.
	*/
	virtual void process(const ProcessArgs &args) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
		step();
#pragma GCC diagnostic pop
	}
	/** Override process(const ProcessArgs &args) instead. */
	DEPRECATED virtual void step() {}

	/** Called when the engine sample rate is changed. */
	virtual void onSampleRateChange() {}
	/** Called when user clicks Initialize in the module context menu. */
	virtual void onReset() {}
	/** Called when user clicks Randomize in the module context menu. */
	virtual void onRandomize() {}
	/** Called when the Module is added to the Engine */
	virtual void onAdd() {}
	/** Called when the Module is removed from the Engine */
	virtual void onRemove() {}

	json_t *toJson();
	void fromJson(json_t *rootJ);

	/** Override to store extra internal data in the "data" property of the module's JSON object. */
	virtual json_t *dataToJson() { return NULL; }
	virtual void dataFromJson(json_t *root) {}
};


} // namespace engine
} // namespace rack
